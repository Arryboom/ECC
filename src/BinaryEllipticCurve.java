package src;

/**
 * @author Aaron Blumenfeld
 * The following program implements elliptic curves. Non-supersingular elliptic
 * curves over binary fields are of the form y^2 + xy = x^3 + ax^2 + b.  They have
 * no repeated roots on the right side of the equation, which is
 * equivalent to b != 0. The isEC method tests if a given equation is an elliptic
 * curve or not. Point and curve orders, logarithms, and lists of points are
 * implemented. There are also static methods for generating
 * lists of elliptic curves.
 * 
 * No methods exist for finding elliptic curves of prime order since these curves
 * over binary fields always have an even number of points. Indeed, the inverse of
 * a point (x, y) is (x, x + y). In particular, the inverse of (0, y) is (0, y). Thus
 * if (0, y) is on the curve, we have a subgroup of order 2. (0, y) is on the curve
 * iff y^2 = b has a solution. But it turns out that every element of the finite field
 * F_(2^k) has a square root, so there is always a point on the curve of the form (0, y).
 * One constructive way to see this is that b^(2^m-1) = 1 by Lagrange's Theorem, so
 * b^(2^m) = (b^(2^(m-1)))^2 = b.
 * 
 * There are also supersingular elliptic curves over binary fields. These have the form
 * y^2 + cy = x^3 + ax + b. I have not implemented these. Although these can be interesting
 * to study, it is known that discrete logarithms on supersingular elliptic curves over F_q can
 * be solved by transformation into discrete logarithms in F_(q^k) for fairly small k. For this
 * reason, supersingular elliptic curves are typically avoided in cryptography.
 * 
 * The logarithm calculator just uses brute force. I considered
 * using something like Pollard's Rho algorithm, but that would require
 * inverting numbers modulo n (or possibly modulo n/k for some k > 1 and
 * checking the k possibilities modulo n). This could be done, but
 * it's overkill for dealing with relatively small groups. log returns -1
 * if no logarithm is found. (E.g., if the point P is in a coset separate from the 
 * subgroup generated by G.)
 */

import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class BinaryEllipticCurve {

    private Polynomial a;
    private Polynomial b;
    private Polynomial modulus;
   
    public BinaryEllipticCurve(Polynomial a, Polynomial b, Polynomial modulus) {
        this.a = a;
        this.b = b;
        this.modulus = modulus;
    }
   
    public BinaryEllipticCurve(BinaryEllipticCurve E) {
        this.a = new Polynomial(E.getA());
        this.b = new Polynomial(E.getB());
        this.modulus = new Polynomial(E.getModulus());
    }
    
    public Polynomial getA() {
    	return a;
    }
    
    public Polynomial getB() {
    	return b;
    }
    
    public Polynomial getModulus() {
    	return modulus;
    }
    
    public void setA(Polynomial a) {
    	this.a = a;
    }
    
    public void setB(Polynomial b) {
    	this.b = b;
    }
    
    public void setModulus(Polynomial modulus) {
    	this.modulus = modulus;
    }
   
	public String toString() {
		String t = "E(F_" + (1<<modulus.degree()) + ") : "; 
		String s = "y^2 + xy = x^3";
		if(!a.equals(new Polynomial())) {
			s += " + (" + a + ")x^2";
		}
		if(!b.equals(new Polynomial())) {
			s += " + (" + b + ")";
		}
		return t + s;
	}
	
	public boolean isEC() {
		Polynomial b = getB();
		return !b.equals(new Polynomial()); /* make sure no multiple roots */
	}
	
	public long order() {
		ArrayList<Polynomial> polys = new ArrayList<Polynomial>();
		for(int i = 0; i < modulus.degree(); i++) {
			Polynomial.generatePolys(polys);
		}
		long count = 1; // point at infinity
		for(int i = 0; i < polys.size(); i++) {
			for(int j = 0; j < polys.size(); j++) {
				Polynomial leftside = (polys.get(j).mult(polys.get(j))).mod(modulus); // y^2
				leftside = (leftside.add(polys.get(i).mult(polys.get(j)))).mod(modulus); // y^2 + xy
				Polynomial rightside = polys.get(i).modExp(3, modulus); // x^3
				rightside = rightside.add(a.mult(polys.get(i).modExp(2, modulus)).mod(modulus)); // x^3 + ax^2
				rightside = rightside.add(b); // x^3 + ax^2 + b
				if(leftside.equals(rightside)) {
					count++;
				}
			}
		}
		return count;
	}
	
	public long pointOrder(PolynomialPoint G) {		
		Polynomial a = getA();
		Polynomial b = getB();
		Polynomial modulus = getModulus();
		PolynomialPoint infinity = new PolynomialPoint();
		long temp = 1 << getModulus().degree(); // use max possible order to avoid O(q^2) curve order computation
		long N = (long)(temp + 1 + 2*Math.sqrt(temp));
		PolynomialPoint P = new PolynomialPoint(); // P = infinity
		
		for(int i = 1; i <= N; i++) {
			P = P.add(G, a, b, modulus);
			if(P.equals(infinity)) {
				return i;
			}
		}
		return -1; /* error */
	}
	
	public long log(PolynomialPoint P, PolynomialPoint G) { /* return k, where kG = P */
		long temp = 1 << getModulus().degree(); // use max possible order to avoid O(q^2) curve order computation
		long N = (long)(temp + 1 + 2*Math.sqrt(temp));
		PolynomialPoint B = new PolynomialPoint(); // B = infinity
		for(long i = 1; i <= N; i++) {
			if((B = G.add(B, getA(), getB(), getModulus())).equals(P)) {
				return i;
			}
		}
		return -1; /* error */
	}
	
	public String listPoints() {
		ArrayList<Polynomial> polys = new ArrayList<Polynomial>();
		for(int i = 0; i < modulus.degree(); i++) {
			Polynomial.generatePolys(polys);
		}
		String s = "";
		for(int i = 0; i < polys.size(); i++) {
			for(int j = 0; j < polys.size(); j++) {
				Polynomial x = polys.get(i);
				Polynomial y = polys.get(j);
				Polynomial leftside = y.mult(y).mod(modulus); // y^2
				leftside = leftside.add(x.mult(y)).mod(modulus); // y^2 + xy
				Polynomial rightside = x.modExp(3, modulus); // x^3
				rightside = rightside.add(a.mult(x.modExp(2, modulus)).mod(modulus)); // x^3 + ax^2
				rightside = rightside.add(b); // x^3 + ax^2 + b
				if(leftside.equals(rightside)) {
					s += new PolynomialPoint(x, y, new Polynomial("1")) + ", ";
				}
			}
		}
		s += "infinity\n";
		return s;
	}
	
	public String listGmults(PolynomialPoint G) {
		String s = "";
		long N = pointOrder(G);
		PolynomialPoint temp = new PolynomialPoint(G);
		for(long i = 1; i < N; i++) {
			s += temp + ", ";
			temp = temp.add(G, getA(), getB(), getModulus());
		}
		s += temp + "\n";
		return s;
	}
	
	public static String listECs(long m, Polynomial irred) throws IOException {
		if((m & (m-1)) != 0) { // only powers of 2 don't have this property
			return "" + m + " is not a power of 2.";
		}
		if(m > 64) {
			return "F_" + m + " is too large. Generate a smaller number of randomly generated curves, or choose F_m with m <= 64.";
		}
		int count = 0;
		String rval = "";
		ArrayList<Polynomial> polys = new ArrayList<Polynomial>();
		int deg = (int)(Math.log(m)/Math.log(2));
		for(int i = 0; i < deg; i++) {
			Polynomial.generatePolys(polys);
		}
		
		for(Polynomial a : polys) {
			for(Polynomial b : polys) {
				BinaryEllipticCurve E = new BinaryEllipticCurve(a, b, irred);
				if(E.isEC()) {
					rval += E.toString() + "\n";
					count++;
				}
			}
		}
		rval += count + " curves were generated.\n";
		return rval;
	}
	
	public static String listRandomECs(long m, Polynomial irred, long n) throws IOException {
		if((m & (m-1)) != 0) { // only powers of 2 don't have this property
			return "" + m + " is not a power of 2.";
		}
		int count = 0;
		BinaryEllipticCurve E;
		Polynomial a, b;
		String rval = "";
		int deg = (int)(Math.log(m)/Math.log(2));
		while(n > 0) {
			a = Polynomial.random(deg-1);
			b = Polynomial.random(deg-1);
			E = new BinaryEllipticCurve(a, b, irred);
			if(E.isEC()) {
				rval += E.toString() + "\n";
				count++;
				n--;
			}
		}
		rval += count + " curves were generated.\n";
		return rval;
	}
	
	public static void main(String[] args) throws IOException { /* method for testing */
		BinaryEllipticCurve E = new BinaryEllipticCurve(new Polynomial("z^3"), new Polynomial("z^3 + 1"), new Polynomial("z^4 + z + 1"));
		System.out.println(E.order());
		System.out.println(E + "\n");
		System.out.println(E.listPoints());
		Polynomial irr = new Polynomial("z^10 + z^9 + z^4 + z + 1");
		System.out.println(listRandomECs(1024, irr, 10));
		PolynomialPoint G = new PolynomialPoint(new Polynomial("z^3"), new Polynomial("1"), new Polynomial("1"));
		System.out.println(E.pointOrder(G));
		System.out.println(E.listGmults(G));
		PolynomialPoint P = new PolynomialPoint(new Polynomial("z^3 + z + 1"), new Polynomial("z"), new Polynomial("1"));
		System.out.println(E.log(P, G));
		
		irr = new Polynomial("z^6 + z + 1");
		for(int i = 1; i <= 1; i++) {
			System.out.println(listECs(65, irr));
		}
	}
}